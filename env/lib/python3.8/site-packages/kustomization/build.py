import os
import sys

import yaml

MERGE_PATCH_PREFIX = "patch__"
IMAGE_REGEX = "(?P<registry>[\w\-\/\_\:\.]*)[\/](?P<image>[\w\-\_]*)[:](?P<versio>[\w\.]*)$"

try:
    from collections.abc import Mapping
except ImportError:
    from collections import Mapping


def get_patches_list(path):
    path = os.path.abspath(path)
    parent, name = os.path.split(path)
    patches = []
    while len(name) > 0:
        patches_file_path = os.path.join(parent, "patches.yaml")
        if os.path.exists(patches_file_path):
            with open(patches_file_path) as f:
                patches.append(load_objects_from_yaml_content(f.read()))
        if "base" in os.listdir(parent):
            patches.reverse()
            return patches
        path = parent
        parent, name = os.path.split(path)
    raise Exception("No \"base\" folder found in project tree!")


def apply_patch(components, patch):
    if patch is not None:

        to_apply = patch.get("patch")
        if to_apply is None:
            return components

        kinds = patch.get("kinds", [])
        if kinds is None:
            kinds = []
        labels_match = patch.get("labelsMatch", [])
        if labels_match is None:
            labels_match = []

        if not check_instances(kinds, labels_match) or (len(kinds) == 0 and len(labels_match) == 0):
            return components

        for index, comp in enumerate(components):
            if matching_kinds(comp["kind"], comp["apiVersion"], kinds) and \
                    matching_labels(comp["metadata"].get("labels", []), labels_match):
                components[index] = update(comp, to_apply)
    return components


def check_instances(kinds, labels_match):
    return isinstance(kinds, list) and isinstance(labels_match, list)


def matching_kinds(kind, version, matches):
    if len(matches) == 0:
        return True
    return "%s:%s" % (version, kind) in matches


def matching_labels(component_labels, matches):
    import re
    for m in matches:
        label, regex = list(m.items())[0]
        if re.match(regex, component_labels.get(label, "")) is None:
            return False
    return True


def build_kustomization(path, images=None):
    import subprocess
    out = subprocess.check_output(['kubectl', 'kustomize', path])
    components = load_objects_from_yaml_content(out)
    patches = get_patches_list(path)
    for patches_list in patches:
        components = update_components_with_patches(components, patches_list)
    for idx, c in enumerate(components):
        if images is not None:
            for imm in images:
                try:
                    container_name, image = imm.split("=")
                except ValueError:
                    print("Image format must match <container name>=<image>", file=sys.stderr)
                    return
                update_service_image_version(c, container_name, image)
        print(yaml.dump(c))
        print("---")


def update_components_with_patches(components, patches):
    for patch in patches:
        components = apply_patch(components, patch)
    return components


def update_service_image_version(component, container_name, image):
    if component_has_containers(component["apiVersion"], component["kind"]):
        try:
            containers = component["spec"]["template"]["spec"]["containers"]
        except KeyError:
            return component
        for cnt in containers:
            if cnt.get("name") == container_name:
                cnt["image"] = image
    return component


def component_has_containers(version, kind):
    return (version.startswith("serving.knative") and kind == "Service") or kind == "Deployment"


def load_objects_from_yaml_content(content):
    objects = []
    if isinstance(content, str):
        objs_str = content.split("---")
    else:
        objs_str = content.split(b"---")
    for patch in objs_str:
        if len(patch) > 0:
            objects.append(yaml.load(patch, Loader=yaml.SafeLoader))
    return objects


def update(d, u):
    for k, v in u.items():
        if isinstance(v, Mapping):
            d[k] = update(d.get(k, {}), v)
        elif isinstance(v, list):
            d[k] = merge_list(d.get(k, []), v)
        else:
            d[k] = v
    return d


def merge_list(l1, l2):
    for e in l2:
        if isinstance(e, Mapping):
            if len(e.keys()) == 1:
                key = list(e.keys())[0]
                try:
                    patch_idx = int(key.replace(MERGE_PATCH_PREFIX, ""))
                    l1[patch_idx] = update(l1[patch_idx], e[key])
                    continue
                except ValueError:
                    pass
        l1.append(e)
    return l1
