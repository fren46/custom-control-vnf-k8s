import argparse
import os
import subprocess
import sys
from collections.abc import Mapping

import jinja2
import pkg_resources
import yaml
import shutil

from kustomization.build import build_kustomization, update
from krules_py.user_interactions import get_user_input, get_user_choice, error, warn

# constants

PROJECT_CONF_DIR = ".project"
PROJECT_CONF_FILE_NAME = "config.yaml"
PROJECT_WORKSPACE_FILE_NAME = "workspace.yaml"
DEFAULT_KEY = "default"
PROJECT_SECTION = "project"
PROFILES_SECTION = "profiles"
ASSETS_PATH = pkg_resources.resource_filename("krules_py", "assets")
DEFAULT_RS_TEMPLATE_PATH_KEY = "default_rs_template_path"
PROFILE_ENV_KEY = "KRULES_CLI_PROFILE"
WORKSPACE_CURRENT_PROFILE_KEY = "current_profile"

# Docker registry options
DOCKER_HUB_OPTION = "Docker Hub"
GCR_OPTION = "Google Container Registry"
OTHER_OPTION = "Other"

VALID_PROJECT_NAME_REGEX = "^(?!-)[a-z0-9-]{1,63}(?<!-)$"

# COPY MERGE STRATEGY
MERGE_STRATEGY_APPEND = "append"  # extend list of components without any control
MERGE_STRATEGY_UPDATE = "update"  # update components like patch
MERGE_STRATEGY_MIXED = "mixed"    # extend list of components updating ones with the given pk

UPDATE_TRIGGER_ERROR_MESSAGE = "Only one between --trigger-for-type, --trigger-on-propcahnge, --trigger-sourced, --trigger-attrs can be specified "
# parsers

parser = argparse.ArgumentParser(description="Command line interface for Krules")
subparsers = parser.add_subparsers(dest="scope")

project_parser = subparsers.add_parser("project", help="project handler")
project_subparser = project_parser.add_subparsers(dest="command")
project_init_parser = project_subparser.add_parser("init", help="Project initializer")
project_init_parser.add_argument("location", help="project root folder")
project_init_parser.add_argument("--name", help="the name of project")
project_init_parser.add_argument("-n", "--namespace", help="the namespace of your images")
project_init_parser.add_argument("-d", "--docker-registry",
                                 help="the docker registry where you want to deploy your services")
project_init_parser.add_argument("-i", "--image-base", help="the project base image")

ruleset_parser = subparsers.add_parser('ruleset', help="ruleset handler")
rs_subparsers = ruleset_parser.add_subparsers(dest='command')

create_rs_parser = rs_subparsers.add_parser("create", help="usage rules create <ruleset name>")
create_rs_parser.add_argument("name", type=str, help="the name of the ruleset which will be created")
create_rs_parser.add_argument("-t", "--template-dir", help="ruleset template folders path")
create_rs_parser.add_argument("-s", "--service-type", help="ruleset template folders path", choices=["knative",
                                                                                                      "base"])

build_rs_parser = rs_subparsers.add_parser("patch", help="usage ruleset patch <path>")
build_rs_parser.add_argument("-p", "--path", help="kustomization.yaml path")
build_rs_parser.add_argument("--set-image", help="format <container_name>=<image>", nargs="+")

build_dockerfile_parser = rs_subparsers.add_parser("build-dockerfile", help="compile Dockerfile.origin")

gen_rs_template_parser = subparsers.add_parser('gen-rs-template', help="generate custom ruleset template")
gen_rs_template_parser.add_argument("location", nargs='?', default=None, help="relative template path")
gen_rs_template_parser.add_argument("--set-default", action='store_true',
                                    help="set <location> params as default rulesets template")
gen_rs_template_parser.add_argument("--unset-default", action='store_true', help="reset default rulesets template")

profile_parser = subparsers.add_parser('profile', help="profiles handler")
profile_subparsers = profile_parser.add_subparsers(dest='command')

get_current_profiles_parser = profile_subparsers.add_parser("get")

set_current_profiles_parser = profile_subparsers.add_parser("set")
set_current_profiles_parser.add_argument("profile_name", help="profile name")

list_profiles_parser = profile_subparsers.add_parser("list")

get_value_profiles_parser = profile_subparsers.add_parser("get-value")
get_value_profiles_parser.add_argument("key", help="value to get from profile")

set_value_profiles_parser = profile_subparsers.add_parser("set-value")
set_value_profiles_parser.add_argument("key", help="profile property to edit")
set_value_profiles_parser.add_argument("value", help="new property's value")

get_all_values_profiles_parser = profile_subparsers.add_parser("values")

add_profile_parser = profile_subparsers.add_parser("add")
add_profile_parser.add_argument("name", help="profile name")
add_profile_parser.add_argument("-ns", "--namespace", help="set profile namespace")
add_profile_parser.add_argument("-d", "--docker-registry", help="set profile docker registry")
add_profile_parser.add_argument("--set-default", action="store_true", help="set the new profile as default")


trigger_parser = subparsers.add_parser('trigger', help="trigger creator")
trigger_subparsers = trigger_parser.add_subparsers(dest='command')

create_tr_parser = trigger_subparsers.add_parser("create", help="usage trigger create <trigger name> [PARAMS..]")
create_tr_parser.add_argument("name", type=str, help="the name of the trigger which will be added")
create_tr_parser.add_argument("--type", help="add a trigger for the given type")
create_tr_parser.add_argument("--on-propchange", help="add a trigger on the given property changes")
create_tr_parser.add_argument("--attrs", nargs="+", help="usage --attrs attr1=value1 attr2=value2")

# main

def main():
    args = vars(parser.parse_args())
    if args.get("scope"):
        parse_args(args)
    else:
        parser.print_help(sys.stdout)


def parse_args(args):
    scope = args.get("scope")
    command = args.get("command")

    if scope == "project":
        if command == "init":
            init_project_tree(
                args.get("name"),
                args.get("location"),
                args.get("namespace"),
                args.get("docker_registry"),
                args.get("image_base")
            )
        else:
            project_parser.print_help(sys.stdout)
    elif scope == "ruleset":
        if command == "create":
            init_ruleset_tree(
                args.get("name"), args.get("template_dir"), args.get("service_type"))
        elif command == "patch":
            patch_kustomization(args.get("path"), args.get("set_image"))
        elif command == "build-dockerfile":
            build_docker_file(os.getcwd())
        else:
            ruleset_parser.print_help(sys.stdout)
    elif scope == "trigger":
        name = args.get("name")
        if args.get("type"):
            if args.get("on_propchange") or args.get("attrs"):
                error(UPDATE_TRIGGER_ERROR_MESSAGE)
                return
            else:
                update_ruleset(resourceKinds=["Trigger"], triggerKind="trigger-for-type",
                               type=args.get("type"), merge_strategy=MERGE_STRATEGY_MIXED,
                               pk="metadata.name", triggerName=name)
        elif args.get("on_propchange"):
            if args.get("type") or args.get("attrs"):
                error(UPDATE_TRIGGER_ERROR_MESSAGE)
                return
            else:
                update_ruleset(resourceKinds=["Trigger"], triggerKind="trigger-on-propchange",
                               propertyName=args.get("on_propchange"), merge_strategy=MERGE_STRATEGY_MIXED,
                               pk="metadata.name", triggerName=name)
        elif args.get("attrs"):
            if args.get("type") or args.get("on_propchange"):
                error(UPDATE_TRIGGER_ERROR_MESSAGE)
                return
            else:
                attributes = {}
                for attr in args.get("attrs"):
                    try:
                        k, v = attr.split("=")
                    except ValueError:
                        error("Bad formatted attributes (expected attr=value)")
                        return
                    if k in attributes:
                        error("Duplicated attribute %s" % k)
                        return
                    attributes[k] = v
                update_ruleset(resourceKinds=["Trigger"], triggerKind="trigger-attrs",
                               triggerAttributes=attributes, merge_strategy=MERGE_STRATEGY_MIXED,
                               pk="metadata.name", triggerName=name)
        else:
            update_ruleset(resourceKinds=["Trigger"], triggerKind="trigger-sourced", triggerSourced=name,
                           merge_strategy=MERGE_STRATEGY_MIXED, pk="metadata.name", triggerName=name)
    elif scope == "gen-rs-template":
        location = args.get("location")
        if location is not None:
            export_rs_template_from_assets(location, args.get("set_default"))
        elif args.get("unset_default"):
            unset_default()
        else:
            gen_rs_template_parser.print_help()
    elif scope == "profile":
        if command == "get":
            print(get_current_profile_name())
        elif command == "set":
            set_current_profile(args.get("profile_name"))
        elif command == "list":
            get_profiles_list()
        elif command == "get-value":
            print(get_profile_value(args.get("key")))
        elif command == "set-value":
            set_profile_value(args.get("key"), args.get("value"))
        elif command == "values":
            print_current_profile_values()
        elif command == "add":
            project_root = get_project_root(os.getcwd())
            add_profile(args.get("name"), project_root, args.get("namespace"), args.get("docker_registry"),
                        args.get("set_default"))
        else:
            profile_parser.print_help()
    else:
        parser.print_help()


# project

def init_project_tree(project_name, project_location, namespace, docker_registry, image_base):
    if project_location is None:
        project_location = os.getcwd()
    project_location = os.path.abspath(project_location)

    if os.path.exists(os.path.join(project_location, PROJECT_CONF_DIR)):
        error('Project already exists in %s' % project_location)
        return

    if project_name is not None and not is_valid_project_name(project_name):
        error("Project name must match %s" % VALID_PROJECT_NAME_REGEX)
        return

    if project_name is None or len(project_name) == 0:
        default_project_name = get_default_project_name(project_location)
        while project_name is None or len(project_name) == 0:
            answer = get_user_input("Project name [%s]: " % default_project_name)
            if answer == "":
                project_name = default_project_name
            else:
                if is_valid_project_name(answer):
                    project_name = answer
                else:
                    error("Project name must match %s" % VALID_PROJECT_NAME_REGEX)

    config = {PROJECT_SECTION: {"name": project_name}}
    save_config(config, os.path.join(project_location, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME))
    profile = add_profile(DEFAULT_KEY, project_location, namespace, docker_registry, set_default=True)

    defaults = {"projectName": project_name, "dockerRegistry": profile["docker_registry"],
                "projectNamespace": profile["namespace"]}
    with open(os.path.join(ASSETS_PATH, "defaults.yaml")) as df:
        defaults.update(yaml.load(df.read(), Loader=yaml.SafeLoader))
    if image_base is not None:
        defaults["imageBase"] = image_base

    os.makedirs(project_location, exist_ok=True)
    recursive_copy(os.path.join(ASSETS_PATH, "project_tmpl"), project_location, defaults)
    print("Project %s created successfully" % project_name)
    print("Now you have to configure subject storage support\n"
          "Look at \"Config subject storage support\" section in README")


def get_default_project_name(project_location):
        _, default_project_name = os.path.split(project_location)
        if is_valid_project_name(default_project_name):
            return default_project_name
        cleaned_project_name = default_project_name.replace(" ", "-").replace("_", "-").replace(".", "-").lower()
        if is_valid_project_name(cleaned_project_name):
            return cleaned_project_name
        return "my-project"


def is_valid_project_name(name):
    import re
    return re.match(VALID_PROJECT_NAME_REGEX, name) is not None


# ruleset

def init_ruleset_tree(ruleset_name, template_dir, service_type):
    if ruleset_name is None:
        parent, ruleset_name = os.path.split(os.getcwd())
    project_root = get_project_root(os.getcwd())
    project_config = get_config(os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME))
    project_name = project_config[PROJECT_SECTION]["name"]

    os.mkdir(ruleset_name)
    if service_type is None:
        service_type = "knative"

    defaults = {
        "rulesetName": ruleset_name,
        "projectName": project_name,
        "serviceType": service_type,
        "action": "create",
    }
    if template_dir is None or len(template_dir) == 0:
        template_dir = project_config[PROJECT_SECTION].get(DEFAULT_RS_TEMPLATE_PATH_KEY, None)
        if template_dir is None:
            template_dir = os.path.join(ASSETS_PATH, "ruleset_tmpl")
        else:
            template_dir = os.path.join(project_root, template_dir)
    else:
        template_dir = os.path.abspath(template_dir)
    with open(os.path.join(ASSETS_PATH, "defaults.yaml")) as df:
        defaults = update(defaults, yaml.load(df.read(), Loader=yaml.SafeLoader))
    ruleset_path = os.path.abspath(ruleset_name)
    recursive_copy(template_dir, ruleset_path, defaults)
    print("Ruleset %s created successfully" % ruleset_name)


def update_ruleset(merge_strategy, pk=None, **values):
    values["action"] = "update"
    cwd = os.getcwd()
    project_root = get_project_root(cwd)
    _, ruleset_name = os.path.split(cwd)
    project_config = get_config(os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME))
    template_dir = project_config[PROJECT_SECTION].get(DEFAULT_RS_TEMPLATE_PATH_KEY, None)
    if template_dir is None:
        template_dir = os.path.join(ASSETS_PATH, "ruleset_tmpl")
    else:
        template_dir = os.path.join(project_root, template_dir)

    parent, current_folder_name = os.path.split(cwd)
    if current_folder_name == "k8s":
        ruleset_path = parent
        k8s_path = cwd
    else:
        k8s_path = os.path.join(cwd, "k8s")
        if os.path.exists(k8s_path):
            ruleset_path = cwd
        else:
            error("k8s folder not found!")
            return
    service_ref = get_service_ref(k8s_path)
    if service_ref is None:
        error("No Service found in the current directory or in the subdirectory \"k8s\"")
        return
    values.update(service_ref)
    recursive_copy(template_dir, ruleset_path, values,
                   merge_strategy=merge_strategy, pk=pk)


def get_service_ref(k8s_path):
    service_file_path = os.path.join(k8s_path, "service.yaml")
    if not os.path.exists(service_file_path):
        service_file_path = os.path.join(k8s_path, "kservice.yaml")
    try:
        with open(service_file_path) as f:
            service_components = list(yaml.load_all(f, Loader=yaml.SafeLoader))
            if len(service_components) == 1:
                service_components = service_components[0]
    except FileNotFoundError:
        error("%s not found" % service_file_path)
        return None
    if isinstance(service_components, Mapping):
        if service_components.get("kind") == "Service":
            name = service_components.get("metadata", {}).get("name")
            if name is not None:
                return {
                    "serviceApiVersion": service_components.get("apiVersion"),
                    "rulesetName": name
                }
    elif isinstance(service_components, list):
        for c in service_components:
            if c.get("kind") == "Service":
                name = c.get("metadata", {}).get("name")
                if name is not None:
                    return {
                        "serviceApiVersion": c.get("apiVersion"),
                        "rulesetName": name
                    }
    return None


# patch

def patch_kustomization(path, images):
    if path is None or path == "":
        path = os.getcwd()
    if not os.path.exists(os.path.join(path, "kustomization.yaml")):
        path = os.path.join(path, "k8s")
        if not os.path.exists(path):
            error("\"kustomization.yaml\" not found in the current directory or in the subdirectory \"k8s\"")
            return
    if images is not None:
        build_kustomization(path, images=images)
    else:
        build_kustomization(path)


# build-docker-file

def build_docker_file(path):
    origin_filepath = os.path.join(path, "Dockerfile.origin")
    if os.path.exists(origin_filepath):
        project_root = get_project_root(path)
        with open(os.path.join(project_root, "base", "VERSION")) as v:
            version = v.read()
        profile = get_current_profile()
        config = get_config(os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME))
        parsed_content = load_template(
            path, "Dockerfile.origin", dockerRegistry=profile["docker_registry"],
            projectName=config[PROJECT_SECTION]["name"], baseVersion=version
                                       )
        dockerfile_path = os.path.join(path, "Dockerfile")
        with open(dockerfile_path, "w") as dockerfile:
            dockerfile.write(parsed_content)
    else:
        error("Dockerfile.origin not found!")
        return


# gen-rs-template

def export_rs_template_from_assets(dst, set_default):
    dst = os.path.abspath(dst)
    if not os.path.exists(dst):
        os.makedirs(dst)
        recursive_copy(os.path.join(ASSETS_PATH, "ruleset_tmpl"), dst, {}, compile_files=False)
    else:
        valid_answer = False
        while not valid_answer:
            answer = get_user_input("%s already exists, would you want to set it as the default template path [n/Y] ?")
            answer = answer.upper()
            if answer == "" or answer == "Y" or answer == "N":
                valid_answer = True
                set_default = answer != "N"

    if set_default:
        project_root = get_project_root(os.getcwd())
        config_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME)
        config = get_config(os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME))
        config[PROJECT_SECTION][DEFAULT_RS_TEMPLATE_PATH_KEY] = dst.replace(project_root, "")[1:]
        save_config(config, config_path)
        print("%s set as the default template path" % dst)


def unset_default():
    project_root = get_project_root(os.getcwd())
    config_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME)
    config = get_config(config_path)
    try:
        config[PROJECT_SECTION].pop(DEFAULT_RS_TEMPLATE_PATH_KEY)
        save_config(config, config_path)
    except KeyError:
        warn("%s was not set" % DEFAULT_RS_TEMPLATE_PATH_KEY)


# profile


def add_profile(profile_name, project_root, namespace, docker_registry, set_default=False):

    config_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME)
    config = get_config(config_path)

    if PROFILES_SECTION not in config:
        config[PROFILES_SECTION] = {}
    elif profile_name in config[PROFILES_SECTION]:
        error("%s profile already exists" % profile_name)
        return

    if namespace is None or len(namespace) == 0:
        default_namespace = get_default_namespace()
        while namespace is None or len(namespace) == 0:
            answer = get_user_input("Namespace [%s]: " % default_namespace)
            if answer == "":
                namespace = default_namespace
            else:
                namespace = answer

    if docker_registry is None or len(docker_registry) == 0:
        docker_registry = ""
        default_docker_registry = get_default_docker_registry()
        while len(docker_registry) == 0:
            if default_docker_registry is not None:
                output_request = "Docker Registry [%s]: " % default_docker_registry
            else:
                output_request = "Docker Registry: "

            answer = get_user_input(output_request)
            if answer == "":
                if default_docker_registry is not None:
                    docker_registry = default_docker_registry
                else:
                    error("You must set value for Docker Registry")
            else:
                docker_registry = answer.replace(" ", "")
    profile = {"namespace": namespace, "docker_registry": docker_registry}

    config[PROFILES_SECTION][profile_name] = profile
    save_config(config, config_path)
    print("Profile %s added properly" % profile_name)
    if set_default:
        workspace_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_WORKSPACE_FILE_NAME)
        update_workspace(workspace_path, current_profile=profile_name)
        print("Profile %s is now the current one" % profile_name)
    return profile


def get_current_profile_name():
    project_root = get_project_root(os.getcwd())
    workspace_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_WORKSPACE_FILE_NAME)
    workspace = get_workspace(workspace_path)
    return os.environ.get(PROFILE_ENV_KEY, workspace.get(WORKSPACE_CURRENT_PROFILE_KEY))


def set_current_profile(profile_name):
    project_root = get_project_root(os.getcwd())
    config_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME)
    config = get_config(config_path)
    profiles = list(config.get(PROFILES_SECTION, {}).keys())
    if profile_name not in profiles:
        error("\"%s\" is not a valid profile name" % profile_name)
        error("Choose between %s" % str(profiles))
    else:
        workspace_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_WORKSPACE_FILE_NAME)
        update_workspace(workspace_path, current_profile=profile_name)
        print("%s now is the current profile" % profile_name)


def get_profile_value(key):
    profile = get_current_profile()
    value = profile.get(key)
    if key == "docker_registry":
        return value.replace("docker.io/", "")
    return value


def set_profile_value(key, value):
    project_root = get_project_root(os.getcwd())
    config_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME)
    config = get_config(config_path)
    current_profile_name = get_current_profile_name()
    profile = config[PROFILES_SECTION][current_profile_name]
    profile[key] = value
    save_config(config, config_path)


def get_current_profile():
    project_root = get_project_root(os.getcwd())
    config_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME)
    config = get_config(config_path)
    current_profile_name = get_current_profile_name()
    return config[PROFILES_SECTION][current_profile_name]


def print_current_profile_values():
    project_root = get_project_root(os.getcwd())
    config_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME)
    config = get_config(config_path)
    current_profile_name = get_current_profile_name()
    current_profile = config[PROFILES_SECTION][current_profile_name]
    print("[%s]" % current_profile_name)
    print(yaml.dump(current_profile))


def get_profiles_list():
    project_root = get_project_root(os.getcwd())
    config_path = os.path.join(project_root, PROJECT_CONF_DIR, PROJECT_CONF_FILE_NAME)
    config = get_config(config_path)
    for profile_name in config.get(PROFILES_SECTION, {}).keys():
        print(profile_name)


# common

def get_project_root(path):
    path = os.path.abspath(path)
    _, name = os.path.split(path)
    while len(name) > 0:
        if PROJECT_CONF_DIR in os.listdir(path):
            return path
        path, name = os.path.split(path)
    raise Exception("No \"project\" found in folder tree!")


def get_config(path):
    with open(path) as f:
        return yaml.load(f, Loader=yaml.SafeLoader)


def save_config(config, path):
    parent, _ = os.path.split(path)
    try:
        os.makedirs(parent)
    except FileExistsError:
        pass
    with open(path, "w") as f:
        yaml.dump(config, f)


def get_workspace(workspace_path):
    if os.path.exists(workspace_path):
        with open(workspace_path) as f:
            return yaml.load(f, Loader=yaml.SafeLoader)
    else:
        ws = {
            WORKSPACE_CURRENT_PROFILE_KEY: DEFAULT_KEY
        }
        with open(workspace_path, "w") as f:
            yaml.dump(ws, f)
        return ws


def update_workspace(workspace_path, **kwargs):
    ws_obj = get_workspace(workspace_path)
    ws_obj = update(ws_obj, kwargs)
    with open(workspace_path, "w") as f:
        yaml.dump(ws_obj, f)


def get_profile(config, profile_name):
    try:
        return config[PROFILES_SECTION][profile_name]
    except KeyError:
        warn("profile %s not found!" % profile_name)
        return None


def get_default_namespace():
    error("fetching kubectl config...")
    namespace = subprocess.check_output(["kubectl", "config", "current-context", "namespace"])
    if namespace is None:
        return "default"
    return namespace.decode("utf-8").replace("\n", "")


def get_default_docker_registry():
    available_kinds = [DOCKER_HUB_OPTION]
    if is_gcloud_in_path():
        available_kinds.append(GCR_OPTION)
    available_kinds.append(OTHER_OPTION)
    registry_kind = get_user_choice("Which kind of Docker Registry do you want to setup for your project?",
                                    available_kinds)
    if registry_kind == DOCKER_HUB_OPTION:
        while True:
            docker_id = get_user_input("Insert your Docker user id: ")
            if len(docker_id) > 0:
                return "docker.io/%s" % docker_id
    elif registry_kind == GCR_OPTION:
        available_zones = ["eu.gcr.io", "us.gcr.io", "asia.gcr.io"]
        zone = get_user_choice("Which is your GCR zone?", available_zones)
        active_project = subprocess.check_output(
            ['gcloud', 'config', "get-value", "project"]).decode('utf-8').replace("\n", "")
        return "%s/%s" % (zone, active_project)
    elif registry_kind == OTHER_OPTION:
        return os.environ.get("DOCKER_REGISTRY")


def is_gcloud_in_path():
    return shutil.which("gcloud") is not None


def load_template(src, path, **kwargs):
    template_loader = jinja2.FileSystemLoader(searchpath=src)
    template_env = jinja2.Environment(loader=template_loader)
    template = template_env.get_template(path)
    return template.render(**kwargs)


def recursive_copy(src, dst, defaults_template_value, compile_files=True, exclude=(), merge_strategy=None, pk=None):
    for item in os.listdir(src):
        item_path = os.path.join(src, item)
        if os.path.isfile(item_path):
            if _is_file_copy_needed(item_path) and item not in exclude:
                dst_item_path = os.path.join(dst, item)
                if compile_files:
                    parsed_content = load_template(src, item, **defaults_template_value).strip(" \n\t")
                    if parsed_content is not None and len(parsed_content) > 0:
                        if os.path.exists(dst_item_path) and merge_strategy is not None:
                            try:
                                with open(dst_item_path) as f:
                                    original = list(yaml.load_all(f, Loader=yaml.SafeLoader))
                                parsed_content_obj = list(yaml.load_all(parsed_content, Loader=yaml.SafeLoader))
                                if merge_strategy == MERGE_STRATEGY_UPDATE:
                                    if len(original) == 1:
                                        original = original[0]
                                    else:
                                        raise ValueError(
                                            "Cannot use \"update\" margre strategy with multiple documents")
                                    if len(parsed_content_obj) == 1:
                                        parsed_content_obj = parsed_content_obj[0]
                                    else:
                                        raise ValueError(
                                            "Cannot use \"update\" margre strategy with multiple documents")
                                    parsed_content = yaml.dump(update(original, parsed_content_obj))
                                elif merge_strategy == MERGE_STRATEGY_APPEND:
                                    original.extend(parsed_content_obj)
                                    parsed_content = _dump_yaml_obj_list(original)
                                elif merge_strategy == MERGE_STRATEGY_MIXED:
                                    if pk is None:
                                        raise ValueError("If you use \"mixed\" merge strategy \"pk\" cannot be None")
                                    for pc in parsed_content_obj:
                                        to_update_pk = _get_pk_value(pc, pk)
                                        to_append = True
                                        for idx, orig in enumerate(original):
                                            if pc.get("kind") == orig.get("kind") and \
                                                    _get_pk_value(orig, pk) == to_update_pk:
                                                original[idx] = update(orig, pc)
                                                to_append = False
                                                break
                                        if to_append:
                                            original.append(pc)
                                    parsed_content = _dump_yaml_obj_list(original)
                            except TypeError:
                                pass
                        with open(dst_item_path, "w") as item_file:
                            item_file.write(parsed_content)
                        if item.endswith(".yaml") and item != "kustomization.yaml":
                            kustomization_path = os.path.join(dst, "kustomization.yaml")
                            if os.path.exists(kustomization_path):
                                add_kustomization_resource(kustomization_path, item)
                                # TODO make it works also for subfolders
                else:
                    shutil.copy(item_path, dst_item_path)

        elif os.path.isdir(item_path):
            if item != "__pycache__" and item not in exclude:
                new_dst = os.path.join(dst, item)
                os.makedirs(new_dst, exist_ok=True)
                if compile_files and item == "templates":
                    recursive_copy(item_path, new_dst, defaults_template_value, compile_files=False, exclude=exclude,
                                   merge_strategy=merge_strategy, pk=pk)
                else:
                    recursive_copy(item_path, new_dst, defaults_template_value, compile_files=compile_files,
                                   exclude=exclude, merge_strategy=merge_strategy, pk=pk)


def _get_pk_value(obj, pk):
    """
    :param obj:
    :param pk: format key or section.subsection.key
    :return:
    """
    if pk is None:
        return None
    keys = pk.split(".")
    v = None
    for k in keys:
        try:
            if v is None:
                v = obj.get(k)
            else:
                v = v.get(k)
        except KeyError:
            return None
        except AttributeError:
            return None
    return v


def _dump_yaml_obj_list(l):
    dumped = ""
    for idx, e in enumerate(l):
        dumped += yaml.dump(e)
        if idx < len(l) -1:
            dumped += "---\n"
    return dumped


def _is_file_copy_needed(file_path):
    _, name = os.path.split(file_path)
    if name != "__init__.py":
        return True
    with open(file_path) as f:
        return len(f.read().replace(" ", "").replace("\n", "").replace("\t", "")) > 0


def add_kustomization_resource(kustomization_path, new_resource):
    with open(kustomization_path) as f:
        kustomization = yaml.load(f, Loader=yaml.SafeLoader)
    resources = kustomization.get("resources", [])
    if not new_resource in resources:
        resources.append(new_resource)
        with open(kustomization_path, "w") as f:
            f.write(yaml.dump(kustomization))


if __name__ == '__main__':
    main()
